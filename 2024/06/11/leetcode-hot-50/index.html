<!DOCTYPE html><html lang="ZN-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Leetcode热题100-前30 | Xiaoma's blog</title><meta name="author" content="Nocturne"><meta name="copyright" content="Nocturne"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="哈希1. 两数之和使用unordered_map创建一个哈希表，对于数值num，查找是否存在target-num，返回对应的索引 12345678910111213141516class Solution &amp;#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode热题100-前30">
<meta property="og:url" content="https://nocturne228.github.io/2024/06/11/leetcode-hot-50/index.html">
<meta property="og:site_name" content="Xiaoma&#39;s blog">
<meta property="og:description" content="哈希1. 两数之和使用unordered_map创建一个哈希表，对于数值num，查找是否存在target-num，返回对应的索引 12345678910111213141516class Solution &amp;#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &amp;#123;">
<meta property="og:locale" content="zn_CN">
<meta property="og:image" content="https://nocturne228.github.io/my_image/haibara4.jpg">
<meta property="article:published_time" content="2024-06-11T04:16:27.000Z">
<meta property="article:modified_time" content="2024-06-11T04:18:04.368Z">
<meta property="article:author" content="Nocturne">
<meta property="article:tag" content="OJ">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nocturne228.github.io/my_image/haibara4.jpg"><link rel="shortcut icon" href="/img/terminal-solid.svg"><link rel="canonical" href="https://nocturne228.github.io/2024/06/11/leetcode-hot-50/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leetcode热题100-前30',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-11 12:18:04'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custombg.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-pen-nib"></i><span> Articles</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tablets"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/diary/"><i class="fa-fw fa-solid fa-book"></i><span> Diary</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/code/"><i class="fa-fw fas fa-bug"></i><span> Code</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/my_image/haibara4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Xiaoma's blog"><span class="site-name">Xiaoma's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-pen-nib"></i><span> Articles</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tablets"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/diary/"><i class="fa-fw fa-solid fa-book"></i><span> Diary</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/code/"><i class="fa-fw fas fa-bug"></i><span> Code</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Leetcode热题100-前30</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-11T04:16:27.000Z" title="Created 2024-06-11 12:16:27">2024-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-06-11T04:18:04.368Z" title="Updated 2024-06-11 12:18:04">2024-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OJ/">OJ</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OJ/Leetcode/">Leetcode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>39mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Leetcode热题100-前30"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>使用<code>unordered_map</code>创建一个哈希表，对于数值<code>num</code>，查找是否存在<code>target-num</code>，返回对应的索引</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (umap.count(target - nums[i]) &amp;&amp; (umap[target - nums[i]] != i)) &#123;</span><br><span class="line">                ans.push_back(umap[target - nums[i]]);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h2><p>组合字母组成相同的单词，编译原理写过类似的题，可以先将所有单词按照字典序排序，然后创建哈希表即可。</p>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h2><p>可以使用<code>unordered_set</code>，对其中的每个数字判断其前驱数<code>num-1</code>是否在哈希表中，如果不在，则其是一个新的序列，重新计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果输入数组为空，则最长连续序列的长度为0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有数字插入到一个哈希集合中，以去除重复元素并加快查找速度</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; <span class="title function_">num_set</span><span class="params">(nums.begin(), nums.end())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化最长连续序列的长度</span></span><br><span class="line">        <span class="type">int</span> longest_streak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历哈希集合中的每个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字的前驱数字不在集合中，说明它是一个新的序列的起点</span></span><br><span class="line">            <span class="keyword">if</span> (!num_set.count(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 初始化当前连续序列的起点</span></span><br><span class="line">                <span class="type">int</span> current_num = num;</span><br><span class="line">                <span class="comment">// 初始化当前连续序列的长度</span></span><br><span class="line">                <span class="type">int</span> current_streak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查当前数字的后继数字是否存在于集合中</span></span><br><span class="line">                <span class="keyword">while</span> (num_set.count(current_num + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果存在，延长当前序列并增加序列长度</span></span><br><span class="line">                    current_num += <span class="number">1</span>;</span><br><span class="line">                    current_streak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最长连续序列的长度</span></span><br><span class="line">                longest_streak = <span class="built_in">std</span>::max(longest_streak, current_streak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最长连续序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> longest_streak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="3-Longesst-substring-without-repeating-characters"><a href="#3-Longesst-substring-without-repeating-characters" class="headerlink" title="3. Longesst substring without repeating characters"></a>3. Longesst substring without repeating characters</h2><p>这道题的解法很巧妙：使用unordered_set维护一个窗口，使用双指针遍历字符串，如果窗口中存在当前字符，说明有重复字符，则移动左指针直到无重复字符，然后右指针继续向右移动，每次移动都会更新答案，保持答案为窗口最大值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="type">char</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            <span class="keyword">while</span> (window.count(c)) &#123;</span><br><span class="line">                window.erase(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            window.insert(c);</span><br><span class="line">            ans = max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只需要遍历一次数组，时间复杂度为$\mathcal{O}(n)$​​</p>
<h2 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438. Find All Anagrams in a String"></a>438. Find All Anagrams in a String</h2><p>很自然地想到哈希表，因为本质上是要找到pattern中各个字母各自出现的次数在原字符中的对应起始下标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; result, hash(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> ls = s.length(), lp = p.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lp; i++) &#123;</span><br><span class="line">            hash[p[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= ls - lp; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">tempHash</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; i + lp; j++) &#123;</span><br><span class="line">                tempHash[s[j] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempHash == hash) &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>上述操作虽然逻辑简洁，但是时间复杂度为$\mathcal{O}(mn)$，有很多冗余操作。可以参考KMP算法来保存前面的判断结果。提高算法效率：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; result, hashP(<span class="number">26</span>, <span class="number">0</span>), window(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> ls = s.length(), lp = p.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ls &lt; lp) <span class="keyword">return</span> result; <span class="comment">// s 比 p 短时直接返回空结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计 p 的字符频率</span></span><br><span class="line">        <span class="comment">// 先在window窗口中添加s和p的前lp个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lp; i++) &#123;</span><br><span class="line">            hashP[p[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            window[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较初始窗口和 p 的字符频率</span></span><br><span class="line">        <span class="keyword">if</span> (window == hashP) result.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="comment">// 窗口逐步向右移动，判断是否仍然与</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lp; i &lt; ls; i++) &#123;</span><br><span class="line">            <span class="comment">// 移除左端字符，添加右端字符</span></span><br><span class="line">            window[s[i - lp] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            window[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 比较当前窗口和 p 的字符频率</span></span><br><span class="line">            <span class="keyword">if</span> (window == hashP) result.push_back(i - lp + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很重要的一点是：</p>
<blockquote>
<p>   vector重载了比较运算符 <code>==</code> 和 <code>!=</code>。这些运算符允许我们直接比较两个 <code>std::vector</code> 对象是否相等或不等。当我们使用 <code>==</code> 运算符比较两个 <code>std::vector</code> 时，实际进行的是元素逐个比较，只有当两个向量的大小相同并且对应位置的元素都相等时，比较结果才为 <code>true</code>。</p>
</blockquote>
<h2 id="560-Subarray-sum-k"><a href="#560-Subarray-sum-k" class="headerlink" title="560. Subarray sum = k"></a>560. Subarray sum = k</h2><p>哈希表+前缀和，基础模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; prefixSumCount; <span class="comment">// 哈希表存储前缀和及其出现次数</span></span><br><span class="line">        prefixSumCount[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化前缀和为0的情况</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            currentSum += num; <span class="comment">// 计算当前前缀和</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查是否存在前缀和，使得 currentSum - k = 之前的某个前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (prefixSumCount.count(currentSum - k)) &#123;</span><br><span class="line">                result += prefixSumCount[currentSum - k];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新哈希表中当前前缀和的出现次数</span></span><br><span class="line">            prefixSumCount[currentSum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="239-Sliding-Windows-Maximum"><a href="#239-Sliding-Windows-Maximum" class="headerlink" title="239. Sliding Windows Maximum"></a>239. Sliding Windows Maximum</h2><p>使用双端队列存储数组元素的索引，然后维护此队列成为单调队列，front处为最大值，每次弹出队列中小于当前元素的元素和超出窗口尺寸的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; deq;  <span class="comment">// 双端队列，存储数组元素的索引</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ans; <span class="comment">// 存储结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 移除队列中所有不在当前窗口范围内的元素</span></span><br><span class="line">            <span class="keyword">if</span> (!deq.empty() &amp;&amp; deq.front() == i - k) &#123;</span><br><span class="line">                deq.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移除队列中所有小于当前元素 nums[i] 的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!deq.empty() &amp;&amp; nums[deq.back()] &lt; nums[i]) &#123;</span><br><span class="line">                deq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将当前元素的索引 i 添加到队列的尾部</span></span><br><span class="line">            deq.push_back(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果窗口已经形成，添加当前窗口的最大值到结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                ans.push_back(nums[deq.front()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p>没想到的思路：初始化一个非零位置的<code>lastNonZeroFoundAt</code>指针表示此位置之前的元素全部非0，然后遍历数组：如果当前位置元素不为0，则将此元素移动至非零指针处，然后<code>lastNonZeroFoundAt</code>指针向前移动。在移动非零元素后，如果<code>lastNonZeroFoundAt</code>指针与当前索引不一致，说明发生了元素移动，则将<code>i</code>的位置填充0，表示移位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化非零元素放置位置指针</span></span><br><span class="line">        <span class="type">int</span> lastNonZeroFoundAt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素不是0</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前元素移动到 lastNonZeroFoundAt 指针所在位置</span></span><br><span class="line">                nums[lastNonZeroFoundAt] = nums[i];</span><br><span class="line">                <span class="comment">// 如果 i 不等于 lastNonZeroFoundAt，说明发生了移动</span></span><br><span class="line">                <span class="keyword">if</span> (i != lastNonZeroFoundAt) &#123;</span><br><span class="line">                    nums[i] = <span class="number">0</span>; <span class="comment">// 将当前位置填充为0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移动 lastNonZeroFoundAt 指针到下一个位置</span></span><br><span class="line">                lastNonZeroFoundAt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>暴力搜索是每次都从当前指针出发遍历数组，时间复杂度为$\mathcal{O}^2$，通过了55/62个样例，超时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> maxWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; height.size(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> currentWater = <span class="number">0</span>;</span><br><span class="line">                currentWater = min(height[i], height[j]) * (j - i);</span><br><span class="line">                maxWater = max(currentWater, maxWater);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用双指针优化，可以先设置位于数组两端的指针，然后每次移动较低的容器，找到最大值，直到两指针相遇：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化左右指针</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化最大面积</span></span><br><span class="line">        <span class="type">int</span> maxWater = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当左指针小于右指针时进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 计算当前容器的高度和宽度</span></span><br><span class="line">            <span class="type">int</span> currentHeight = <span class="built_in">std</span>::min(height[left], height[right]);</span><br><span class="line">            <span class="type">int</span> currentWidth = right - left;</span><br><span class="line">            <span class="comment">// 计算当前容器的面积</span></span><br><span class="line">            <span class="type">int</span> currentWater = currentHeight * currentWidth;</span><br><span class="line">            <span class="comment">// 更新最大面积</span></span><br><span class="line">            maxWater = <span class="built_in">std</span>::max(maxWater, currentWater);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动较小高度的指针以尝试找到更大的面积</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><p>先对数组排序方便指针查找，然后固定第一个指针。如果当前位置的元素与上一位置元素相同，则跳过以避免重复判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 排序数组</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，固定第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素与上一个元素相同，跳过以避免重复</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用双指针寻找另外两个元素</span></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 找到满足条件的三元组，加入结果集</span></span><br><span class="line">                    result.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动左指针跳过重复元素</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 移动右指针跳过重复元素</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动指针寻找下一组元素</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于0，移动左指针以增加总和</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于0，移动右指针以减小总和</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="精简代码"><a href="#精简代码" class="headerlink" title="精简代码"></a>精简代码</h3><p>0x3f的解法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; x == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">if</span> (x + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 优化一</span></span><br><span class="line">            <span class="keyword">if</span> (x + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 优化二</span></span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> s = x + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (s &gt; <span class="number">0</span>) --k;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; <span class="number">0</span>) ++j;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.push_back(&#123;x, nums[j], nums[k]&#125;);</span><br><span class="line">                    <span class="keyword">for</span> (++j; j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]; ++j); <span class="comment">// 跳过重复数字</span></span><br><span class="line">                    <span class="keyword">for</span> (--k; k &gt; j &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]; --k); <span class="comment">// 跳过重复数字</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：灵茶山艾府</span></span><br><span class="line"><span class="comment">链接：https://leetcode.cn/problems/3sum/solutions/1968332/shuang-zhi-zhen-xiang-bu-ming-bai-yi-ge-pno55/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><h3 id="双指针解法-1"><a href="#双指针解法-1" class="headerlink" title="双指针解法"></a>双指针解法</h3><p>双指针方法：维护两个指针从两端向中间扫描，并记录每个位置的最大高度来计算雨水量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置左右指针</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> waterTrapped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果左边的高度小于右边的高度，则处理左边</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                <span class="comment">// 当前高度大于或等于左边最大高度，更新左边最大高度</span></span><br><span class="line">                <span class="comment">// 否则计算当前高度能够接住的水量</span></span><br><span class="line">                <span class="keyword">if</span> (height[left] &gt;= leftMax) &#123;</span><br><span class="line">                    leftMax = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    waterTrapped += leftMax - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右侧同理</span></span><br><span class="line">                <span class="keyword">if</span> (height[right] &gt;= rightMax) &#123;</span><br><span class="line">                    rightMax = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    waterTrapped += rightMax - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> waterTrapped;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = height.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">leftMax</span><span class="params">(n)</span>, <span class="title function_">rightMax</span><span class="params">(n)</span>;</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个位置左边的最大高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMax[i] = max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个位置右边的最大高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightMax[i] = max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> waterTrapped = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算每个位置能够接住的水量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            waterTrapped += min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> waterTrapped;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="滑动窗口-2"><a href="#滑动窗口-2" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="3-最长重复子串"><a href="#3-最长重复子串" class="headerlink" title="3. 最长重复子串"></a>3. 最长重复子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, n = s.<span class="built_in">length</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; window;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            <span class="keyword">while</span> (window.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                window.<span class="built_in">erase</span>(s[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">insert</span>(c); <span class="comment">// 加入 c</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>); <span class="comment">// 更新窗口长度最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>用了一个<code>unordered_set</code>作为节点的哈希表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* ptrA = headA;</span><br><span class="line">        ListNode* ptrB = headB;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; uset;</span><br><span class="line">        ListNode* ans = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptrA) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">count</span>(ptrA)) &#123;</span><br><span class="line">                ptrA = ptrA-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uset.<span class="built_in">insert</span>(ptrA);</span><br><span class="line">            ptrA = ptrA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ptrB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">count</span>(ptrB)) &#123;</span><br><span class="line">                ans = ptrB;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ptrB = ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>来自柳神的解法，我的原想法是开辟一个栈自然实现倒序，柳神是直接在内部交换指针的指向关系，非常妙</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">reverseList</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* curr = head, *prev = <span class="literal">NULL</span>, *temp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>还是用栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* nptr = head;</span><br><span class="line">        <span class="keyword">while</span> (nptr) &#123;</span><br><span class="line">            stk.push(nptr);</span><br><span class="line">            nptr = nptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        nptr = head;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.top()-&gt;val == nptr-&gt;val) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                nptr = nptr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p><code>unordered_set</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(ListNode *head)</span> &#123;</span><br><span class="line">        ListNode* nptr = head;</span><br><span class="line">        <span class="keyword">if</span> (nptr == <span class="literal">NULL</span> || nptr-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; uset;</span><br><span class="line">        <span class="keyword">while</span> (nptr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.count(nptr)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            uset.insert(nptr);</span><br><span class="line">            nptr = nptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142. 环形链表II"></a>142. 环形链表II</h2><p>这样的空间复杂度为$\mathcal{O}(n)$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode *<span class="title function_">detectCycle</span><span class="params">(ListNode *head)</span> &#123;</span><br><span class="line">        ListNode* nptr = head;</span><br><span class="line">        ListNode* ans = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; uset;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nptr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.count(nptr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nptr;</span><br><span class="line">            &#125;</span><br><span class="line">            uset.insert(nptr);</span><br><span class="line">            nptr = nptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>柳神的代码类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode *<span class="title function_">detectCycle</span><span class="params">(ListNode *head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; uset;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            uset.insert(p);</span><br><span class="line">            <span class="keyword">if</span> (cnt == uset.size()) <span class="keyword">return</span> p;</span><br><span class="line">            cnt = uset.size();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>官方题解提供了一个快慢指针的思路，可以将空间复杂度优化到$\mathcal{O}(1)$​。</p>
<p>在链表上有两个移速不同的指针，如果这两个指针能够相遇，则一定存在环，这是检测是否有环的经典算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode *<span class="title function_">detectCycle</span><span class="params">(ListNode *head)</span> &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p>实际上是多个分类处理。首先声明一个表头，然后遍历两个链表：当一个链表上的节点的值较小时，加入答案链表，然后将这个链表上的指针后移。当有链表达到尾端时，另一个链表余下的部分直接加入链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> &#123;</span><br><span class="line">        ListNode* dum = new ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dum;</span><br><span class="line">        <span class="keyword">while</span> (list1 != nullptr &amp;&amp; list2 != nullptr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = list1 != nullptr ? list1 : list2;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2. 两数之和"></a>2. 两数之和</h2><p>使用链表倒序存储两数，一步步进位得到两数之和，思路不难，主要是模拟平时的加法计算过程，大概用于大数求和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = new ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* nptr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != nullptr || l2 != nullptr || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> value = carry;</span><br><span class="line">            <span class="keyword">if</span> (l1 != nullptr) &#123;</span><br><span class="line">                value += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != nullptr) &#123;</span><br><span class="line">                value += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            carry = value / <span class="number">10</span>;</span><br><span class="line">            nptr-&gt;next = new ListNode(value % <span class="number">10</span>);</span><br><span class="line">            nptr = nptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next; <span class="comment">// 返回结果链表的头节点（去除初始化的0节点）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19. 删除链表的倒数第 N 个节点"></a>19. 删除链表的倒数第 N 个节点</h2><p>我的原代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> nullptr;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode* ptr = head;</span><br><span class="line">            <span class="keyword">while</span> (ptr-&gt;next) &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr-&gt;next = nullptr;</span><br><span class="line">            delete ptr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fptr = head;</span><br><span class="line">        ListNode* sptr = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sptr = sptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sptr-&gt;next) &#123;</span><br><span class="line">            fptr = fptr-&gt;next;</span><br><span class="line">            sptr = sptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fptr-&gt;next = sptr;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到无法处理n超出链表长度的情况以及删除操作存在逻辑错误。</p>
<p>改进代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哑节点，指向头节点，处理边界情况</span></span><br><span class="line">        ListNode* dummy = new ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* first = dummy;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让 second 指针先走 n+1 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (second == nullptr) <span class="keyword">return</span> head; <span class="comment">// n 超过链表长度</span></span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动 first 和 second 指针直到 second 指向链表末尾</span></span><br><span class="line">        <span class="keyword">while</span> (second != nullptr) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除第 n 个节点</span></span><br><span class="line">        ListNode* nodeToDelete = first-&gt;next;</span><br><span class="line">        first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line">        delete nodeToDelete;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回处理后的链表头节点</span></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;</span><br><span class="line">        delete dummy; <span class="comment">// 释放哑节点内存</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建dummy节点简化边界处理，实际上就是数据结构课里的不带值的头结点。然后让second指针走n+1步，这样才能正确删除节点，也就是两节点中间隔了一个节点。注意后面的while语句中的判断条件是<code>second != nullptr</code>，这样second节点实际上走到了尾节点的后一节点的位置，也就是空值处，这时删除的节点正是倒数第N个节点。</p>
<h2 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h2><p>主要是对链表各节点的next进行操作，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">swapPairs</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = new ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (prev-&gt;next &amp;&amp; prev-&gt;next-&gt;next) &#123;</span><br><span class="line">            ListNode* first = prev-&gt;next;</span><br><span class="line">            ListNode* second = prev-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            first-&gt;next = second-&gt;next;</span><br><span class="line">            second-&gt;next = first;</span><br><span class="line">            prev-&gt;next = second;</span><br><span class="line">            prev = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;</span><br><span class="line">        delete dummy;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的代码非常简短，但是不容易理解。可以从栈顶的情况开始分析：当只有一个元素时，不再递归，直接返回当前链表。由于我们创建的变量为<code>newHead = head-&gt;next</code>，而传入的参数是<code>newHead-&gt;next</code>，那么返回的便是<code>head-&gt;next-&gt;next</code>。由交换的示意图可以得知，<code>head-&gt;next = head-&gt;next-&gt;next</code>。最后，表头的两节点交换：<code>newHead-&gt;next = head;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">swapPairs</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(newHead-&gt;next);</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在循环中，程序检查当前节点<code>temp</code>及其后面是否有足够的两个节点进行交换。如果有，则进行节点交换操作。</p>
<ul>
<li><code>node1</code>指向当前节点的下一个节点，即第一个要交换的节点。</li>
<li><code>node2</code>指向<code>node1</code>的下一个节点，即第二个要交换的节点。</li>
<li>然后，程序进行节点交换操作：<ul>
<li>将<code>temp</code>的<code>next</code>指针指向<code>node2</code>，实现交换。</li>
<li>将<code>node1</code>的<code>next</code>指针指向<code>node2</code>的下一个节点，连接后续节点。</li>
<li>将<code>node2</code>的<code>next</code>指针指向<code>node1</code>，完成节点交换。</li>
</ul>
</li>
<li>最后，将<code>temp</code>移动到下一组要交换的节点的前一个节点，继续循环直到链表末尾或无法再进行交换。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    public ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != null &amp;&amp; temp.next.next != null) &#123;</span><br><span class="line">            ListNode node1 = temp.next;</span><br><span class="line">            ListNode node2 = temp.next.next;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h2><p>类似24：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = new ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count % k == <span class="number">0</span>) &#123;</span><br><span class="line">                prev = reverse(prev, head-&gt;next);</span><br><span class="line">                head = prev-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;</span><br><span class="line">        delete dummy;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    ListNode* <span class="title function_">reverse</span><span class="params">(ListNode* prev, ListNode* next)</span> &#123;</span><br><span class="line">        ListNode* last = prev-&gt;next;</span><br><span class="line">        ListNode* current = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (current != next) &#123;</span><br><span class="line">            last-&gt;next = current-&gt;next;</span><br><span class="line">            current-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = current;</span><br><span class="line">            current = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>三个指针<code>current</code>、<code>prev</code>和<code>nextNode</code>，分别表示当前节点、前一个节点和下一个节点。然后利用循环将每k个节点进行翻转操作。翻转操作就是将当前节点的next指针指向前一个节点，然后更新prev和current指针。</p>
<p>翻转完成后，head节点指向翻转后的最后一个节点，prev指针指向翻转后的头节点。接下来，程序使用递归调用自身来翻转下一个k个节点，并将翻转后的头节点连接到翻转前的尾部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* nextGroupHead = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nextGroupHead) &#123;</span><br><span class="line">                <span class="keyword">return</span> head; <span class="comment">// 如果长度不够k，直接返回头节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            nextGroupHead = nextGroupHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ListNode* nextNode = current-&gt;next;</span><br><span class="line">            current-&gt;next = prev;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head-&gt;next = reverseKGroup(nextGroupHead, k); <span class="comment">// 将翻转后的头节点连接下一个k的头节点</span></span><br><span class="line">        <span class="keyword">return</span> prev; <span class="comment">// 返回翻转后的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h2><h3 id="回溯-哈希"><a href="#回溯-哈希" class="headerlink" title="回溯+哈希"></a>回溯+哈希</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line"></span><br><span class="line">    Node* <span class="title function_">copyRandomList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == nullptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.count(head)) &#123;</span><br><span class="line">            Node* headNew = new Node(head-&gt;val);</span><br><span class="line">            cachedNode[head] = headNew;</span><br><span class="line">            headNew-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">            headNew-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// If the input list is empty, return nullptr.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Original List:</span></span><br><span class="line"><span class="comment">            1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line"><span class="comment">            |    |    |</span></span><br><span class="line"><span class="comment">            v    v    v</span></span><br><span class="line"><span class="comment">            2   null  1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// First pass: Create a new node for each existing node and interleave them.</span></span><br><span class="line">        <span class="comment">// 遍历原始链表，对于每个节点，创建一个新节点并将其插入到原节点之后</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            After interleaving:</span></span><br><span class="line"><span class="comment">            1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27; -&gt; null</span></span><br><span class="line"><span class="comment">            |          |          |</span></span><br><span class="line"><span class="comment">            v          v          v</span></span><br><span class="line"><span class="comment">            2         null        1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (Node* current = head; current != <span class="literal">nullptr</span>;) &#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(current-&gt;val);</span><br><span class="line">            newNode-&gt;next = current-&gt;next;</span><br><span class="line">            current-&gt;next = newNode;</span><br><span class="line">            current = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Second pass: Assign random pointers for the new nodes.</span></span><br><span class="line">        <span class="comment">// 为新节点设置随机指针</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Interleaved list with `random` pointers set:</span></span><br><span class="line"><span class="comment">            1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27; -&gt; null</span></span><br><span class="line"><span class="comment">            |    |     |    |     |    |</span></span><br><span class="line"><span class="comment">            v    v     v    v     v    v</span></span><br><span class="line"><span class="comment">            2    2&#x27;   null null   1    1&#x27;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (Node* current = head; current != <span class="literal">nullptr</span>; current = current-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                current-&gt;next-&gt;random = current-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Third pass: Separate the original list from the copied list and prepare the return value.</span></span><br><span class="line">        <span class="comment">// 将原始链表和复制链表分开，并恢复原始链表的结构。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Restored original list:</span></span><br><span class="line"><span class="comment">            1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line"><span class="comment">            |    |    |</span></span><br><span class="line"><span class="comment">            v    v    v</span></span><br><span class="line"><span class="comment">            2   null  1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            Separated copied list (deep copy):</span></span><br><span class="line"><span class="comment">            1&#x27; -&gt; 2&#x27; -&gt; 3&#x27; -&gt; null</span></span><br><span class="line"><span class="comment">            |     |     |</span></span><br><span class="line"><span class="comment">            v     v     v</span></span><br><span class="line"><span class="comment">            2&#x27;   null   1&#x27;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node* copiedListHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (Node* current = head; current != <span class="literal">nullptr</span>;) &#123;</span><br><span class="line">            Node* copiedNode = current-&gt;next;</span><br><span class="line">            <span class="comment">// Advance the current pointer in the original list to the next original node</span></span><br><span class="line">            current-&gt;next = copiedNode-&gt;next;</span><br><span class="line">            <span class="comment">// Advance the copiedNode pointer in the copied list to the next copied node, </span></span><br><span class="line">            <span class="comment">// if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (copiedNode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                copiedNode-&gt;next = copiedNode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Move to the next original node</span></span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the head of the copied list.</span></span><br><span class="line">        <span class="keyword">return</span> copiedListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：对链表做了3次遍历，为$\mathcal{O}(N)$；空间复杂度：实用的额外空间是常数级，为$\mathcal{O}(1)$​</p>
<h2 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h2><p>自定义一个lambda表达式（类似重载比较符），然后维护一个最小堆自动排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">sortList</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> ListNode&amp; a, <span class="type">const</span> ListNode&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.val &gt; b.val; <span class="comment">// 根据 val 的值从大到小排序</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode, <span class="built_in">vector</span>&lt;ListNode&gt;, decltype(cmp)&gt; pq(cmp);</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            pq.push(*curr);</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode <span class="title function_">dummy</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">        ListNode* tail = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            tail-&gt;next = new ListNode(pq.top().val);</span><br><span class="line">            pq.pop();</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>递归调用sort函数来进行归并排序：即每次将链表均分为两段，然后对各个halves进行分类，最后合并每个有序链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">sortList</span><span class="params">(ListNode* head)</span> &#123;</span><br><span class="line">        <span class="comment">// Base case: if the list is empty or has only one element, it is already sorted.</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the fast and slow pointer approach to find the middle of the list</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Split the list into two halves</span></span><br><span class="line">        ListNode* midNext = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = nullptr;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// Recursively sort both halves</span></span><br><span class="line">        ListNode* leftHalf = sortList(head);</span><br><span class="line">        ListNode* rightHalf = sortList(midNext);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// Merge the two sorted halves</span></span><br><span class="line">        ListNode* dummyHead = new ListNode();</span><br><span class="line">        ListNode* current = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (leftHalf &amp;&amp; rightHalf) &#123;</span><br><span class="line">            <span class="comment">// Choose the smaller value from either half</span></span><br><span class="line">            <span class="keyword">if</span> (leftHalf-&gt;val &lt;= rightHalf-&gt;val) &#123;</span><br><span class="line">                current-&gt;next = leftHalf;</span><br><span class="line">                leftHalf = leftHalf-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current-&gt;next = rightHalf;</span><br><span class="line">                rightHalf = rightHalf-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Move to the next node in the merged list</span></span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// If there are remaining nodes in either half, append them to the merged list</span></span><br><span class="line">        current-&gt;next = leftHalf ? leftHalf : rightHalf;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// The merged sorted list is pointed to by the dummy head&#x27;s next node</span></span><br><span class="line">        ListNode* sortedHead = dummyHead-&gt;next;</span><br><span class="line">        delete dummyHead; <span class="comment">// Clean up the dummy node</span></span><br><span class="line">        <span class="keyword">return</span> sortedHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为$\mathcal{O}(n\log n)$​</p>
<h2 id="23-Merge-K-sorted-lists"><a href="#23-Merge-K-sorted-lists" class="headerlink" title="23. Merge K sorted lists"></a>23. Merge K sorted lists</h2><p>优先队列就是神</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode *<span class="title function_">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Lambda function to compare two ListNode pointers for the min-heap</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](ListNode *a, ListNode *b)</span><br><span class="line">        &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Priority queue (min-heap) to keep track of the smallest element</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, decltype(cmp)&gt; minHeap(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insert the first node of each list into the heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">list</span> : lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                minHeap.push(<span class="built_in">list</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dummy head to ease the merging process</span></span><br><span class="line">        ListNode dummy;</span><br><span class="line">        ListNode *current = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Extract the smallest node from the heap</span></span><br><span class="line">            ListNode *minNode = minHeap.top();</span><br><span class="line">            minHeap.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the smallest node to the merged list</span></span><br><span class="line">            current-&gt;next = minNode;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the extracted node has a next node, insert it into the heap</span></span><br><span class="line">            <span class="keyword">if</span> (minNode-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                minHeap.push(minNode-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next; <span class="comment">// Return the head of the merged list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h2><p>实际就是手动实现双线链表+哈希表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> key, value;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> k = <span class="number">0</span>, <span class="type">int</span> v = <span class="number">0</span>) : key(k), value(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    Node *dummy; <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, Node*&gt; key_to_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个节点（抽出一本书）</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">remove</span><span class="params">(Node *x)</span> &#123;</span><br><span class="line">        x-&gt;prev-&gt;next = x-&gt;next;</span><br><span class="line">        x-&gt;next-&gt;prev = x-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头添加一个节点（把一本书放在最上面）</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">push_front</span><span class="params">(Node *x)</span> &#123;</span><br><span class="line">        x-&gt;prev = dummy;</span><br><span class="line">        x-&gt;next = dummy-&gt;next;</span><br><span class="line">        x-&gt;prev-&gt;next = x;</span><br><span class="line">        x-&gt;next-&gt;prev = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *<span class="title function_">get_node</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key_to_node.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_to_node.end()) <span class="comment">// 没有这本书</span></span><br><span class="line">            <span class="keyword">return</span> nullptr;</span><br><span class="line">        <span class="keyword">auto</span> node = it-&gt;second; <span class="comment">// 有这本书</span></span><br><span class="line">        remove(node); <span class="comment">// 把这本书抽出来</span></span><br><span class="line">        push_front(node); <span class="comment">// 放在最上面</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(<span class="type">int</span> capacity) : capacity(capacity), dummy(new Node()) &#123;</span><br><span class="line">        dummy-&gt;prev = dummy;</span><br><span class="line">        dummy-&gt;next = dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = get_node(key);</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;value : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = get_node(key);</span><br><span class="line">        <span class="keyword">if</span> (node) &#123; <span class="comment">// 有这本书</span></span><br><span class="line">            node-&gt;value = value; <span class="comment">// 更新 value</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        key_to_node[key] = node = new Node(key, value); <span class="comment">// 新书</span></span><br><span class="line">        push_front(node); <span class="comment">// 放在最上面</span></span><br><span class="line">        <span class="keyword">if</span> (key_to_node.size() &gt; capacity) &#123; <span class="comment">// 书太多了</span></span><br><span class="line">            <span class="keyword">auto</span> back_node = dummy-&gt;prev;</span><br><span class="line">            key_to_node.erase(back_node-&gt;key);</span><br><span class="line">            remove(back_node); <span class="comment">// 去掉最后一本书</span></span><br><span class="line">            delete back_node; <span class="comment">// 释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-Binary-tree-inorder-traversal"><a href="#94-Binary-tree-inorder-traversal" class="headerlink" title="94. Binary tree inorder traversal"></a>94. Binary tree inorder traversal</h2><p>拆解中序遍历的过程：</p>
<ol>
<li>The left subtree is traversed first</li>
<li>Then the root node for that subtree is traversed</li>
<li>Finally, the right subtree is traversed</li>
</ol>
<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>直接左中右：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder(root-&gt;left, ans);</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        inorder(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><p>中序遍历的过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://media.geeksforgeeks.org/wp-content/uploads/20230303154301/inorder.gif" alt="inorder"></p>
<p>将递归写法改为迭代，实际就是使用栈来模拟递归调用的函数栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr || !stk.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr) &#123;</span><br><span class="line">                stk.push(curr);</span><br><span class="line">                <span class="comment">// 先一直沿着左子树方向移动</span></span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到最后被遍历的节点，就是其自己的根节点。</span></span><br><span class="line">                curr = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                ans.push_back(curr-&gt;val);</span><br><span class="line">                <span class="comment">// 因为左子树已经被遍历完了</span></span><br><span class="line">                <span class="comment">// 寻找右子树</span></span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="104-Maximum-depth-of-binary-tree"><a href="#104-Maximum-depth-of-binary-tree" class="headerlink" title="104. Maximum depth of binary tree"></a>104. Maximum depth of binary tree</h2><p>不停地向左子树和右子树递归，更新向左或向右的最大深度，实际上是一个dfs。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode *root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l_depth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r_depth = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> max(l_depth, r_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h3><p>维护一个队列，从根节点root开始，每次遍历队列中所有节点（通过开始时候的队列大小获取节点个数），然后push进所有节点的所有子节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> depth;</span><br><span class="line"></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="type">int</span> n = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><p>使用了模板，这里实际上是一个Inorder Traversal，每次遍历将当前深度+1，二维vector的result中对应下标的vector即为对应层次的所有节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">order</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nullptr) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.size() == depth) result.push_back(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].push_back(cur-&gt;val);</span><br><span class="line">        order(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        order(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        order(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="226-Invert-binary-tree"><a href="#226-Invert-binary-tree" class="headerlink" title="226. Invert binary tree"></a>226. Invert binary tree</h2><p>很容易想到递归</p>
<h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><p>对每个节点的left child和right child，递归调用函数，最后交换左右：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">invertTree</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">        TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间和空间复杂度都是$\mathcal{O}(n)$</p>
<h3 id="迭代-4"><a href="#迭代-4" class="headerlink" title="迭代"></a>迭代</h3><p>使用一个栈来辅助遍历二叉树节点，对于遇到的每一个节点，交换左右子节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">invertTree</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            TreeNode* curr = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换当前节点的左右子节点</span></span><br><span class="line">            TreeNode* temp = curr-&gt;left;</span><br><span class="line">            curr-&gt;left = curr-&gt;right;</span><br><span class="line">            curr-&gt;right = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将子节点加入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;left) &#123;</span><br><span class="line">                stk.push(curr-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;right) &#123;</span><br><span class="line">                stk.push(curr-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="101-Symmetric-tree"><a href="#101-Symmetric-tree" class="headerlink" title="101. Symmetric tree"></a>101. Symmetric tree</h2><h3 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h3><p>这个也很自然地想到递归解法，实际上是对树做了一个遍历，但是不能按照left child和right child来判断，而是要按照“外侧”和“里侧”来分类。也就是根的左子树要等于根的右子树，左子树的右子树要等于右子树的左子树，也就是里侧相等，外侧相等。</p>
<p>体现完整逻辑的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == nullptr &amp;&amp; right != nullptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != nullptr &amp;&amp; right == nullptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == nullptr &amp;&amp; right == nullptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> outside = compare(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = compare(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;</span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>精简后为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> compare(left-&gt;left, right-&gt;right) &amp;&amp; compare(left-&gt;right, right-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="迭代-5"><a href="#迭代-5" class="headerlink" title="迭代"></a>迭代</h2><p>维护一个队列，判空后，每次判断一对节点是否相等，在加入队列时也两两成对加入队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* left = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* right = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!left &amp;&amp; !right) <span class="keyword">continue</span>;  <span class="comment">// 左右节点都为空，对称，继续检查</span></span><br><span class="line">            <span class="keyword">if</span> (!left || !right) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 一个为空，一个不为空，不对称</span></span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 两个节点值不相等，不对称</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将子节点按对称顺序加入队列</span></span><br><span class="line">            q.push(left-&gt;left);</span><br><span class="line">            q.push(right-&gt;right);</span><br><span class="line">            q.push(left-&gt;right);</span><br><span class="line">            q.push(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实际上改用栈也完全可以：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        stk.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* left = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* right = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!left || !right || left-&gt;val != right-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stk.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            stk.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            stk.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            stk.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="unordered-map-amp-set"><a href="#unordered-map-amp-set" class="headerlink" title="unordered_map&amp;set"></a>unordered_map&amp;set</h2><p><code>unordered_map</code> is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have <strong>average constant-time complexity</strong>. Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the <strong>hash</strong> of its key.</p>
<p>可以看到<code>unordered_map</code>的内部实现是hash，而<code>map</code>的内部是红黑树，这也就是是否“unordered”的区别，二者的各项操作的平均时间复杂度分别为$\mathcal{O}(1)$和$\mathcal{O}(\log_2 N)$​。<code>map</code>的迭代效率更高而<code>unordered_map</code>的操作效率更高。</p>
<h2 id="dummy-node"><a href="#dummy-node" class="headerlink" title="dummy node"></a>dummy node</h2><blockquote>
<p>  A linked list implementation may use a <strong>dummy node</strong> (or <strong>header node</strong>): A node with an unused data member that always resides at the head of the list and cannot be removed. Using a dummy node simplifies the algorithms for a linked list because the head and tail pointers are never null. An empty list consists of the dummy node, which has the next pointer set to null, and the list’s head and tail pointers both point to the dummy node. Singly-linked lists with and without a dummy node.</p>
</blockquote>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>The <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type">priority queue</a>) is a <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container#Container_adaptors">container adaptor</a> that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.</p>
<p>A user-provided <code>Compare</code> can be supplied to change the ordering, e.g. using <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/utility/functional/greater">std::greater</a><T> would cause the smallest element to appear as the <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/priority_queue/top">top()</a>.</p>
<p><code>priority_queue</code>实际维护了一个有序堆，通过<code>greater&lt;T&gt;</code>或<code>less&lt;T&gt;</code>（默认）分别设定为最小堆和最大堆，即越小的元素越靠近堆顶或越大的元素越靠近堆顶。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://nocturne228.github.io">Nocturne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://nocturne228.github.io/2024/06/11/leetcode-hot-50/">https://nocturne228.github.io/2024/06/11/leetcode-hot-50/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OJ/">OJ</a><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="social-share" data-image="/my_image/haibara4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/21/FastAPIDoc/" title="FastAPI文档学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/haibara3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">FastAPI文档学习</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/14/lambdaCal-FP/" title="lambda演算与函数式编程初见"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/haibara2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">lambda演算与函数式编程初见</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/03/24/Leetcode-01/" title="Leetcode_01"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/haibara1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-24</div><div class="title">Leetcode_01</div></div></a></div><div><a href="/2024/03/24/Acwing-01/" title="Acwing_01"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/haibara2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-24</div><div class="title">Acwing_01</div></div></a></div><div><a href="/2024/03/24/CCF-CSP-01/" title="CCF_CSP_01"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/haibara1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-24</div><div class="title">CCF_CSP_01</div></div></a></div><div><a href="/2024/04/08/OJ-graph/" title="图算法专题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/haibara3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">图算法专题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/my_image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nocturne</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/nocturne228"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Nocturne228" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:nocturne2282282@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">嗨害嗨，来了嗷</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">1.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.1.</span> <span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">49. 字母异位词分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">128. 最长连续序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Longesst-substring-without-repeating-characters"><span class="toc-number">2.1.</span> <span class="toc-text">3. Longesst substring without repeating characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-Find-All-Anagrams-in-a-String"><span class="toc-number">2.2.</span> <span class="toc-text">438. Find All Anagrams in a String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-Subarray-sum-k"><span class="toc-number">2.3.</span> <span class="toc-text">560. Subarray sum &#x3D; k</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-Sliding-Windows-Maximum"><span class="toc-number">2.4.</span> <span class="toc-text">239. Sliding Windows Maximum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">3.1.</span> <span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">3.3.</span> <span class="toc-text">15. 三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">双指针解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">精简代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">3.4.</span> <span class="toc-text">42. 接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">双指针解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.4.2.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">3.4.3.</span> <span class="toc-text">单调栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2"><span class="toc-number">4.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">4.1.</span> <span class="toc-text">3. 最长重复子串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">5.2.</span> <span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">5.4.</span> <span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="toc-number">5.5.</span> <span class="toc-text">142. 环形链表II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">5.5.1.</span> <span class="toc-text">快慢指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">5.6.</span> <span class="toc-text">21. 合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">5.7.</span> <span class="toc-text">2. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">5.8.</span> <span class="toc-text">19. 删除链表的倒数第 N 个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Swap-Nodes-in-Pairs"><span class="toc-number">5.9.</span> <span class="toc-text">24. Swap Nodes in Pairs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">5.9.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.9.2.</span> <span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Reverse-Nodes-in-k-Group"><span class="toc-number">5.10.</span> <span class="toc-text">25. Reverse Nodes in k-Group</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-number">5.10.1.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-Copy-List-with-Random-Pointer"><span class="toc-number">5.11.</span> <span class="toc-text">138. Copy List with Random Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-%E5%93%88%E5%B8%8C"><span class="toc-number">5.11.1.</span> <span class="toc-text">回溯+哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-1"><span class="toc-number">5.11.2.</span> <span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-Sort-List"><span class="toc-number">5.12.</span> <span class="toc-text">148. Sort List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.12.1.</span> <span class="toc-text">归并排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Merge-K-sorted-lists"><span class="toc-number">5.13.</span> <span class="toc-text">23. Merge K sorted lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU-Cache"><span class="toc-number">5.14.</span> <span class="toc-text">146. LRU Cache</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#94-Binary-tree-inorder-traversal"><span class="toc-number">6.1.</span> <span class="toc-text">94. Binary tree inorder traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-number">6.1.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-2"><span class="toc-number">6.1.2.</span> <span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-Maximum-depth-of-binary-tree"><span class="toc-number">6.2.</span> <span class="toc-text">104. Maximum depth of binary tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-3"><span class="toc-number">6.2.1.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-3"><span class="toc-number">6.2.2.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-Invert-binary-tree"><span class="toc-number">6.3.</span> <span class="toc-text">226. Invert binary tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-4"><span class="toc-number">6.3.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-4"><span class="toc-number">6.3.2.</span> <span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-Symmetric-tree"><span class="toc-number">6.4.</span> <span class="toc-text">101. Symmetric tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-5"><span class="toc-number">6.4.1.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-5"><span class="toc-number">6.5.</span> <span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%82%E8%AE%B0"><span class="toc-number">7.</span> <span class="toc-text">杂记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map-amp-set"><span class="toc-number">7.1.</span> <span class="toc-text">unordered_map&amp;set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dummy-node"><span class="toc-number">7.2.</span> <span class="toc-text">dummy node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-number">7.3.</span> <span class="toc-text">priority_queue</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Nocturne</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>